datasource db {
    provider = "mysql"
    url      = "mysql://root:ZJaFfQsGcBua@localhost:3306/chat"
    // url      = env("DATABASE_URL")
}

generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["fullTextSearch", "fullTextIndex"]
}

model Message {
    id        String      @id @default(cuid())
    body      String?     @db.Text
    from      User        @relation(fields: [fromID], references: [id])
    fromID    String
    chat      Conversion  @relation(fields: [chatID], references: [id], onDelete: Cascade)
    chatID    String
    voice     File?       @relation(name: "VoiceFile", fields: [voiceID], references: [id], onDelete: Cascade)
    voiceID   String?     @unique
    type      MessageType @default(TEXT)
    seen      User[]      @relation("seenUsers")
    files     File[]
    createdAt DateTime    @default(now())
    updatedAt DateTime    @updatedAt
}

model File {
    id           String   @id @default(uuid())
    size         Int
    url          String
    uploadedAt   DateTime @default(now())
    message      Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)
    messageId    String?
    // path       String
    // metadata   String
    voiceMessage Message? @relation(name: "VoiceFile")
}

model User {
    id            String    @id @default(uuid())
    name          String
    email         String    @unique
    password      String
    messages      Message[]
    joinAt        DateTime  @default(now())
    emailVerified DateTime?
    image         String

    friends     Friendship[] @relation(name: "requestedFrom")
    friendsFrom Friendship[] @relation(name: "requestedTo")

    conversions Conversion[]
    AdminGroups Conversion[] @relation(name: "admins")
    MessageSeen Message[]    @relation("seenUsers")

    @@fulltext([name])
    @@fulltext([email])
    @@fulltext([name, email])
}

model Friendship {
    requestedFromID String
    requestedFrom   User          @relation(name: "requestedFrom", fields: [requestedFromID], references: [id], onDelete: Cascade)
    requestedTo     User          @relation(name: "requestedTo", fields: [requestedToID], references: [id], onDelete: Cascade)
    requestedToID   String
    status          RequestStatus @default(PENDING)

    @@unique([requestedFromID, requestedToID], name: "id")
}

enum RequestStatus {
    PENDING
    ACCEPTED
    DENIND
}

enum MessageType {
    DELETED
    MEDIA
    FILE
    AUDIO
    TEXT
    INFO
}

model Conversion {
    id          String    @id @default(cuid())
    members     User[]
    description String?   @db.LongText
    is_group    Boolean   @default(false)
    profile     String?
    name        String?
    admins      User[]    @relation(name: "admins")
    messages    Message[]
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt
}
